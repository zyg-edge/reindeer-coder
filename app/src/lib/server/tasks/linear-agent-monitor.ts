import { existsSync, readFileSync, unlinkSync } from 'node:fs';
import { env } from '$env/dynamic/private';
import { configService } from '../config-service';
import {
	createTask,
	getActiveTasksWithLinearMetadata,
	getTasksNeedingAttention,
	markAttentionCheckPosted,
	markConnectionCommandsPosted,
} from '../db';
import type { TaskCreateInput } from '../db/schema';
import { getLinearApiKey } from '../secrets';
import { readTerminalFile } from '../terminal-storage';
import {
	completeTask,
	getActiveConnection,
	manualReconnect,
	sendInstruction,
	startTask,
} from '../vm/orchestrator';
import { CodeReviewHandler } from './code-review-handler';
import { analyzeTerminalOutput } from './terminal-analyzer';

interface PendingTask {
	issueId: string;
	issueIdentifier: string;
	workingLabelId: string;
	outputFile: string;
	startedAt: number;
}

interface LinearLabel {
	id: string;
	name: string;
	color: string;
	parent?: {
		name: string;
	} | null;
}

interface LinearIssue {
	id: string;
	identifier: string;
	title: string;
	description: string | null;
	labels: {
		nodes: LinearLabel[];
	};
	url: string;
	creator: {
		email: string;
		name: string;
	} | null;
}

interface LinearResponse {
	data: {
		issues: {
			nodes: LinearIssue[];
		};
	};
	errors?: Array<{ message: string }>;
}

class LinearAgentMonitor {
	private linearApiKey: string | null = null;
	private pollIntervalMs: number;
	private isRunning: boolean = false;
	private processedIssues: Set<string> = new Set();
	private pendingTasks: Map<string, PendingTask> = new Map();
	private readonly TASK_TIMEOUT_MS = 20 * 60 * 1000; // 20 minutes max
	private codeReviewHandler: CodeReviewHandler;
	private initPromise: Promise<void> | null = null;

	constructor() {
		this.pollIntervalMs = parseInt(env.LINEAR_POLL_INTERVAL_MS || '60000', 10); // Default 60 seconds
		this.codeReviewHandler = new CodeReviewHandler();
	}

	/**
	 * Initialize the monitor by resolving secrets from Secret Manager.
	 */
	private async initialize(): Promise<void> {
		if (this.linearApiKey) return;

		if (!this.initPromise) {
			this.initPromise = (async () => {
				this.linearApiKey = await getLinearApiKey();
			})();
		}

		await this.initPromise;
	}

	/**
	 * Get the Linear API key, initializing if needed.
	 */
	private async getApiKey(): Promise<string> {
		await this.initialize();
		return this.linearApiKey!;
	}

	async start() {
		console.log('[LinearAgentMonitor] Starting monitor...');
		console.log(`[LinearAgentMonitor] Polling interval: ${this.pollIntervalMs}ms`);

		this.isRunning = true;
		await this.poll();
	}

	async stop() {
		console.log('[LinearAgentMonitor] Stopping monitor...');
		this.isRunning = false;
	}

	private async poll() {
		while (this.isRunning) {
			try {
				// Check for new agent tasks
				await this.checkForAgentTasks();
				// Check for completed pending tasks
				await this.checkPendingTasks();
				// Check for completed Linear tickets
				await this.checkCompletedLinearTickets();
				// Check for tasks that need attention
				await this.checkNeedsAttentionTasks();
				// Check for tasks that need connection commands posted
				await this.checkTasksNeedingConnectionCommands();
			} catch (error) {
				console.error('[LinearAgentMonitor] Error during poll:', error);
			}

			// Wait for next poll
			await new Promise((resolve) => setTimeout(resolve, this.pollIntervalMs));
		}
	}

	private async checkPendingTasks() {
		for (const [taskKey, task] of this.pendingTasks) {
			const elapsed = Date.now() - task.startedAt;

			// Check if output file exists (task completed)
			if (existsSync(task.outputFile)) {
				console.log(
					`[LinearAgentMonitor] Task completed for ${task.issueIdentifier}, posting results...`
				);
				try {
					const planOutput = readFileSync(task.outputFile, 'utf-8');

					// Check if it's an error
					if (planOutput.startsWith('ERROR:')) {
						console.error(
							`[LinearAgentMonitor] Claude failed for ${task.issueIdentifier}: ${planOutput}`
						);
						await this.addCommentToIssue(
							task.issueId,
							`‚ùå Agent task failed: ${planOutput}\n\n---\nü§ñ *Claude Code*`
						);
						await this.removeLabelFromIssueById(task.issueId, task.workingLabelId);
						await this.addLabelToIssue(task.issueId, 'Agent/blocked');
					} else {
						// Post the plan to Linear
						const planComment = `## üìã Implementation Plan\n\n${planOutput}\n\n---\nü§ñ *Generated by Claude Code* ‚Ä¢ Ready for human review`;
						await this.addCommentToIssue(task.issueId, planComment);

						// Update labels
						await this.removeLabelFromIssueById(task.issueId, task.workingLabelId);
						await this.addLabelToIssue(task.issueId, 'Human/Review Plan');

						console.log(`[LinearAgentMonitor] Plan posted for ${task.issueIdentifier}`);
					}

					// Clean up
					unlinkSync(task.outputFile);
				} catch (error) {
					console.error(
						`[LinearAgentMonitor] Error posting results for ${task.issueIdentifier}:`,
						error
					);
					await this.addCommentToIssue(
						task.issueId,
						`‚ùå Agent task failed: ${error instanceof Error ? error.message : String(error)}`
					);
				}
				this.pendingTasks.delete(taskKey);
			}
			// Check for timeout
			else if (elapsed > this.TASK_TIMEOUT_MS) {
				console.log(
					`[LinearAgentMonitor] Task timeout for ${task.issueIdentifier} after ${Math.round(elapsed / 1000)}s`
				);
				await this.addCommentToIssue(
					task.issueId,
					`‚ö†Ô∏è Agent task timed out after ${Math.round(elapsed / 60000)} minutes. The task may still be running in the background.\n\n---\nü§ñ *Claude Code*`
				);
				await this.removeLabelFromIssueById(task.issueId, task.workingLabelId);
				await this.addLabelToIssue(task.issueId, 'Agent/blocked');
				this.pendingTasks.delete(taskKey);
			}
		}
	}

	private async checkCompletedLinearTickets() {
		// Get all active tasks with Linear metadata
		const activeTasks = await getActiveTasksWithLinearMetadata();

		console.log(
			`[LinearAgentMonitor] checkCompletedLinearTickets: found ${activeTasks.length} active tasks with Linear metadata`
		);

		if (activeTasks.length === 0) {
			return; // No active tasks to check
		}

		// Fetch issue statuses from Linear for all active tasks
		for (const task of activeTasks) {
			if (!task.metadata?.linear?.issue_id) {
				continue; // Skip tasks without Linear metadata
			}

			try {
				// Fetch the issue status from Linear
				const issueStatus = await this.fetchLinearIssueStatus(task.metadata?.linear?.issue_id);

				if (!issueStatus) {
					console.error(
						`[LinearAgentMonitor] Could not fetch status for issue ${task.metadata?.linear?.issue_identifier}`
					);
					continue;
				}

				console.log(
					`[LinearAgentMonitor] Issue ${task.metadata?.linear?.issue_identifier} status: ${issueStatus.state.type}`
				);

				// Check if the issue is marked as done
				if (issueStatus.state.type === 'completed') {
					console.log(
						`[LinearAgentMonitor] Issue ${task.metadata?.linear?.issue_identifier} is marked as done, completing task ${task.id}`
					);

					// Complete the task (release resources)
					try {
						await completeTask(task.id);
						console.log(`[LinearAgentMonitor] Task ${task.id} marked as complete`);
					} catch (error) {
						console.error(`[LinearAgentMonitor] Failed to complete task ${task.id}:`, error);
						continue;
					}

					// Remove Agent/working label if present
					const workingLabelId = await this.findLabel('Agent/working');
					if (workingLabelId) {
						try {
							await this.removeLabelFromIssueById(task.metadata?.linear?.issue_id, workingLabelId);
							console.log(
								`[LinearAgentMonitor] Removed Agent/working label from ${task.metadata?.linear?.issue_identifier}`
							);
						} catch (error) {
							console.error(
								`[LinearAgentMonitor] Failed to remove Agent/working label from ${task.metadata?.linear?.issue_identifier}:`,
								error
							);
						}
					}

					// Add comment to Linear ticket
					const taskUrl = `${env.APP_URL}/tasks/${task.id}`;
					const comment =
						`‚úÖ **Vibe Coding task marked as complete**\n\n` +
						`The task resources have been released as this ticket was marked as done.\n\n` +
						`[View Task Details ‚Üí](${taskUrl})\n\n` +
						`---\nü§ñ *Claude Code*`;

					await this.addCommentToIssue(task.metadata?.linear?.issue_id, comment);
					console.log(
						`[LinearAgentMonitor] Added completion comment to ${task.metadata?.linear?.issue_identifier}`
					);
				}
			} catch (error) {
				console.error(
					`[LinearAgentMonitor] Error checking completed ticket for task ${task.id}:`,
					error
				);
			}
		}
	}

	private async checkNeedsAttentionTasks() {
		const tasksNeedingAttention = await getTasksNeedingAttention();

		for (const task of tasksNeedingAttention) {
			// Skip if no Linear metadata
			if (!task.metadata?.linear?.issue_id || !task.metadata?.linear?.issue_identifier) {
				continue;
			}

			// Check if already posted attention check (check database field)
			if (task.metadata?.linear?.attention_check_posted) {
				continue;
			}

			// Verify the issue still has Agent/working label before proceeding
			const hasWorkingLabel = await this.issueHasAgentWorkingLabel(task.metadata?.linear?.issue_id);
			if (!hasWorkingLabel) {
				console.log(
					`[LinearAgentMonitor] Task ${task.metadata?.linear?.issue_identifier} no longer has Agent/working label, skipping attention check`
				);
				// Don't mark as processed - re-check on subsequent polls in case label is added back
				continue;
			}

			console.log(
				`[LinearAgentMonitor] Task ${task.metadata?.linear?.issue_identifier} needs attention, analyzing...`
			);

			try {
				// Read terminal output (last 200 lines)
				const terminalOutput = readTerminalFile(task.id, 200);
				if (!terminalOutput) {
					console.log(`[LinearAgentMonitor] No terminal output for ${task.id}`);
					continue;
				}

				// Analyze with Claude
				const analysis = await analyzeTerminalOutput(terminalOutput, task.task_description);

				console.log(
					`[LinearAgentMonitor] Analysis for ${task.metadata?.linear?.issue_identifier}: ${analysis.state}`
				);

				// Try to detect and store MR URL from terminal output
				if (analysis.state === 'agent_done_waiting' || analysis.state === 'still_working') {
					try {
						await this.codeReviewHandler.detectAndStoreMRInfo(task.id, terminalOutput);
					} catch (error) {
						console.error(`[LinearAgentMonitor] Failed to detect MR info for ${task.id}:`, error);
					}
				}

				// Get the working label ID
				const workingLabelId = await this.findLabel('Agent/working');
				if (!workingLabelId) {
					console.error(`[LinearAgentMonitor] Cannot find "Agent/working" label`);
					continue;
				}

				// Handle based on state
				if (analysis.state === 'agent_done_waiting') {
					// Agent is done - remove working label, add review label
					await this.removeLabelFromIssueById(task.metadata?.linear?.issue_id, workingLabelId);
					await this.addLabelToIssue(
						task.metadata?.linear?.issue_id,
						'Human/Review Implementation'
					);

					// Add comment with summary and MR link
					let comment = `## ‚úÖ Implementation Complete\n\n`;
					comment += `${analysis.summary || 'The agent has completed the implementation.'}\n\n`;
					if (analysis.mergeRequestUrl) {
						comment += `**Merge Request**: ${analysis.mergeRequestUrl}\n\n`;
					}
					comment += `[View Task Terminal ‚Üí](${env.APP_URL}/tasks/${task.id})\n\n`;
					comment += `---\nü§ñ *Claude Code* ‚Ä¢ Ready for review`;

					await this.addCommentToIssue(task.metadata?.linear?.issue_id, comment);

					console.log(
						`[LinearAgentMonitor] Marked ${task.metadata?.linear?.issue_identifier} as done`
					);
				} else if (analysis.state === 'needs_user_input') {
					// Agent needs input - keep working label but add comment
					const comment =
						`## ‚ö†Ô∏è Agent Needs Input\n\n` +
						`The agent requires your attention:\n\n` +
						`${analysis.reasoning}\n\n` +
						`[View Task Terminal ‚Üí](${env.APP_URL}/tasks/${task.id})\n\n` +
						`---\nü§ñ *Claude Code*`;

					await this.addCommentToIssue(task.metadata?.linear?.issue_id, comment);

					console.log(
						`[LinearAgentMonitor] Added needs-input comment for ${task.metadata?.linear?.issue_identifier}`
					);
				}
				// If still_working, do nothing - let it continue

				// Mark as posted in database
				await markAttentionCheckPosted(task.id);
			} catch (error) {
				console.error(
					`[LinearAgentMonitor] Error analyzing ${task.metadata?.linear?.issue_identifier}:`,
					error
				);
			}
		}
	}

	private async checkTasksNeedingConnectionCommands() {
		const activeTasks = await getActiveTasksWithLinearMetadata();

		for (const task of activeTasks) {
			// Skip if no Linear metadata or no VM name yet
			if (!task.metadata?.linear?.issue_id || !task.vm_name || !task.vm_zone) {
				continue;
			}

			// Skip if already posted commands for this task (check database field)
			if (task.metadata?.linear?.connection_commands_posted) {
				continue;
			}

			// Only post commands for tasks that are running, cloning, or initializing
			if (!['running', 'cloning', 'initializing'].includes(task.status)) {
				continue;
			}

			console.log(
				`[LinearAgentMonitor] Posting connection commands for ${task.metadata?.linear?.issue_identifier} (task ${task.id})`
			);

			try {
				const project = env.GCP_PROJECT_ID;
				const zone = task.vm_zone;
				const vmName = task.vm_name;
				const tmuxSession = `vibe-${task.id.slice(0, 8)}`;
				const vmUser = await configService.get('vm.user', 'agent', 'VM_USER');

				const sshCommand = `gcloud compute ssh ${vmName} --project=${project} --zone=${zone} --tunnel-through-iap --ssh-flag="-t" -- sudo -u ${vmUser} tmux attach-session -t ${tmuxSession}`;
				const tunnelCommand = `gcloud compute ssh ${vmName} --project=${project} --zone=${zone} --tunnel-through-iap -- -N -L 3715:127.0.0.1:5173`;

				const comment =
					`üîó **Connection Commands Available**\n\n` +
					`The VM is now ready! Use these commands to connect:\n\n` +
					`### Connect from Terminal\n` +
					`\`\`\`bash\n${sshCommand}\n\`\`\`\n\n` +
					`### Test from Local Browser\n` +
					`Run this command in a separate terminal to create a tunnel:\n` +
					`\`\`\`bash\n${tunnelCommand}\n\`\`\`\n\n` +
					`Then open http://localhost:3715 in your browser.\n\n` +
					`[View Task Terminal ‚Üí](${env.APP_URL}/tasks/${task.id})\n\n` +
					`---\nü§ñ *Claude Code*`;

				await this.addCommentToIssue(task.metadata?.linear?.issue_id, comment);

				// Mark as posted in database
				await markConnectionCommandsPosted(task.id);

				console.log(
					`[LinearAgentMonitor] Posted connection commands for ${task.metadata?.linear?.issue_identifier}`
				);
			} catch (error) {
				console.error(
					`[LinearAgentMonitor] Error posting connection commands for ${task.metadata?.linear?.issue_identifier}:`,
					error
				);
			}
		}
	}

	private async checkForAgentTasks() {
		const issues = await this.fetchLinearIssues();

		for (const issue of issues) {
			// Find labels in the "Agent" group (parent.name === 'Agent')
			const agentLabel = issue.labels.nodes.find((label) => label.parent?.name === 'Agent');

			if (!agentLabel) {
				continue;
			}

			// Skip if already processed or pending
			const issueKey = `${issue.id}-${agentLabel.name}`;
			if (this.processedIssues.has(issueKey) || this.pendingTasks.has(issueKey)) {
				continue;
			}

			console.log(
				`[LinearAgentMonitor] Found agent task: ${issue.identifier} - Agent/${agentLabel.name}`
			);

			// Task type is the label name itself (e.g., "plan")
			const taskType = agentLabel.name.toLowerCase();

			try {
				const success = await this.executeTask(issue, taskType, agentLabel.id);

				// Only mark as processed if the task was successfully started
				// If blocked or failed, allow retry on next poll
				if (success) {
					this.processedIssues.add(issueKey);

					// Clean up old processed issues (keep last 1000)
					if (this.processedIssues.size > 1000) {
						const items = Array.from(this.processedIssues);
						this.processedIssues = new Set(items.slice(-1000));
					}
				}
			} catch (error) {
				console.error(`[LinearAgentMonitor] Error executing task for ${issue.identifier}:`, error);
				// Add error comment to issue
				await this.addCommentToIssue(
					issue.id,
					`‚ùå Agent task failed: ${error instanceof Error ? error.message : String(error)}\n\n---\nü§ñ *Claude Code*`
				);
			}
		}
	}

	private async fetchLinearIssues(): Promise<LinearIssue[]> {
		const apiKey = await this.getApiKey();
		const response = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: apiKey,
			},
			body: JSON.stringify({
				query: `
					query {
						issues(
							first: 50
							filter: {
								state: { type: { nin: ["completed", "canceled"] } }
							}
							orderBy: updatedAt
						) {
							nodes {
								id
								identifier
								title
								description
								creator {
									email
									name
								}
								labels {
									nodes {
										id
										name
										color
										parent {
											name
										}
									}
								}
								url
							}
						}
					}
				`,
			}),
		});

		if (!response.ok) {
			throw new Error(`Linear API error: ${response.status} ${response.statusText}`);
		}

		const data: LinearResponse = await response.json();

		if (data.errors) {
			throw new Error(`Linear GraphQL errors: ${JSON.stringify(data.errors)}`);
		}

		return data.data?.issues?.nodes || [];
	}

	private async fetchLinearIssueStatus(
		issueId: string
	): Promise<{ state: { type: string } } | null> {
		const apiKey = await this.getApiKey();
		const response = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: apiKey,
			},
			body: JSON.stringify({
				query: `
					query GetIssueStatus($id: String!) {
						issue(id: $id) {
							id
							state {
								type
							}
						}
					}
				`,
				variables: {
					id: issueId,
				},
			}),
		});

		if (!response.ok) {
			throw new Error(`Linear API error: ${response.status} ${response.statusText}`);
		}

		const data = await response.json();

		if (data.errors) {
			throw new Error(`Linear GraphQL errors: ${JSON.stringify(data.errors)}`);
		}

		return data.data?.issue || null;
	}

	private async executeTask(
		issue: LinearIssue,
		taskType: string,
		agentLabelId: string
	): Promise<boolean> {
		switch (taskType) {
			case 'implement':
				return await this.executeImplementTask(issue, agentLabelId);
			case 'fix implementation':
				return await this.executeFixImplementationTask(issue, agentLabelId);
			case 'code review':
				return await this.executeCodeReviewTask(issue, agentLabelId);
			case 'working':
				// Silently ignore - this is our in-progress state, not a task type
				console.log(`[LinearAgentMonitor] Ignoring working state for ${issue.identifier}`);
				return false; // Don't mark as processed, allow state changes
			case 'blocked':
				// Silently ignore - this is our blocked state, not a task type
				console.log(`[LinearAgentMonitor] Ignoring blocked state for ${issue.identifier}`);
				return false; // Don't mark as processed, allow retries
			default:
				console.log(`[LinearAgentMonitor] Unknown task type: ${taskType}`);
				await this.addCommentToIssue(
					issue.id,
					`‚ö†Ô∏è Unknown agent task type: "${taskType}". Supported types: implement, fix implementation, code review`
				);
				return false; // Don't mark as processed
		}
	}

	private async executeImplementTask(issue: LinearIssue, agentLabelId: string): Promise<boolean> {
		console.log(`[LinearAgentMonitor] Executing implement task for ${issue.identifier}`);

		// FIRST: Immediately swap label from Agent/implement to Agent/working
		const workingLabelId = await this.findLabel('Agent/working');
		if (!workingLabelId) {
			console.error(`[LinearAgentMonitor] Cannot find "Agent/working" label - aborting task`);
			await this.removeLabelFromIssue(issue.id, agentLabelId);
			await this.addCommentToIssue(
				issue.id,
				'‚ùå **Agent task failed**: Required label "Agent/working" not found in Linear.\n\n' +
					'Please create a "working" label under the "Agent" parent group.\n\n' +
					'---\nü§ñ *Claude Code*'
			);
			return false; // Failed, allow retry
		}

		// Swap labels immediately to prevent duplicate pickup
		await this.removeLabelFromIssue(issue.id, agentLabelId);
		await this.addLabelToIssueById(issue.id, workingLabelId);
		console.log(
			`[LinearAgentMonitor] Swapped Agent/implement -> Agent/working for ${issue.identifier}`
		);

		// Get repo from label in "Repo" group
		const repoLabel = issue.labels.nodes.find((label) => label.parent?.name === 'Repo');

		if (!repoLabel) {
			console.log(
				`[LinearAgentMonitor] No repo specified for ${issue.identifier}, marking as blocked`
			);
			await this.addCommentToIssue(
				issue.id,
				'‚ö†Ô∏è **Agent task blocked**: No repository specified.\n\n' +
					'Please add a label from the **Repo** group to specify which repository to work on.\n\n' +
					'Available repositories should be accessible by the Vibe Coding system.\n\n' +
					'---\nü§ñ *Claude Code*'
			);
			await this.removeLabelFromIssueById(issue.id, workingLabelId);
			await this.addLabelToIssue(issue.id, 'Agent/blocked');
			return false; // Blocked, allow retry when repo is added
		}

		const repoName = repoLabel.name;

		// Build repository URL from configured base URL and org
		const gitBaseUrl = await configService.get(
			'git.base_url',
			'https://gitlab.com',
			'GIT_BASE_URL'
		);
		const gitOrg = await configService.get('git.org', '', 'GIT_ORG');
		if (!gitOrg) {
			throw new Error('git.org configuration is required');
		}
		const repoUrl = `${gitBaseUrl}/${gitOrg}/${repoName}.git`;

		// Get default base branch from config
		const baseBranch = await configService.get(
			'git.default_base_branch',
			'main',
			'GIT_DEFAULT_BASE_BRANCH'
		);

		// Get default CLI from config
		const defaultCli = await configService.get(
			'agent.default_cli',
			'claude-code',
			'AGENT_DEFAULT_CLI'
		);
		const codingCli = (defaultCli as 'claude-code' | 'gemini' | 'codex') || 'claude-code';

		try {
			// Trigger the Vibe Coding task
			const taskId = await this.triggerVibeTask(issue, repoUrl, baseBranch, codingCli);

			// Add initial comment with task link
			await this.addCommentToIssue(
				issue.id,
				`üöÄ **Vibe Coding task started**\n\n` +
					`Repository: \`${repoName}\`\n` +
					`Branch: \`${baseBranch}\`\n` +
					`Agent: \`${codingCli}\`\n\n` +
					`[View Live Progress ‚Üí](${env.APP_URL}/tasks/${taskId})\n\n` +
					`Connection commands will be posted once the VM is provisioned...\n\n` +
					`---\nü§ñ *Claude Code*`
			);

			console.log(`[LinearAgentMonitor] Vibe task ${taskId} started for ${issue.identifier}`);

			// Note: Keep Agent/working label - it will be updated by the vibe task workflow
			// The VM orchestrator or completion handler should update labels when done
			return true; // Successfully started
		} catch (error) {
			console.error(`[LinearAgentMonitor] Implement task failed for ${issue.identifier}:`, error);
			await this.addCommentToIssue(
				issue.id,
				`‚ùå **Vibe Coding task failed to start**: ${error instanceof Error ? error.message : String(error)}\n\n` +
					`---\nü§ñ *Claude Code*`
			);
			await this.removeLabelFromIssueById(issue.id, workingLabelId);
			await this.addLabelToIssue(issue.id, 'Agent/blocked');
			throw error;
		}
	}

	private async executeFixImplementationTask(
		issue: LinearIssue,
		agentLabelId: string
	): Promise<boolean> {
		console.log(`[LinearAgentMonitor] Executing fix implementation task for ${issue.identifier}`);

		// FIRST: Immediately swap label from Agent/fix Implementation to Agent/working
		const workingLabelId = await this.findLabel('Agent/working');
		if (!workingLabelId) {
			console.error(`[LinearAgentMonitor] Cannot find "Agent/working" label - aborting task`);
			await this.removeLabelFromIssue(issue.id, agentLabelId);
			await this.addCommentToIssue(
				issue.id,
				'‚ùå **Agent task failed**: Required label "Agent/working" not found in Linear.\n\n' +
					'Please create a "working" label under the "Agent" parent group.\n\n' +
					'---\nü§ñ *Claude Code*'
			);
			return false; // Failed, allow retry
		}

		// Swap labels immediately to prevent duplicate pickup
		await this.removeLabelFromIssue(issue.id, agentLabelId);
		await this.addLabelToIssueById(issue.id, workingLabelId);
		console.log(
			`[LinearAgentMonitor] Swapped Agent/fix Implementation -> Agent/working for ${issue.identifier}`
		);

		// Find the existing active task for this Linear issue
		const activeTasks = await getActiveTasksWithLinearMetadata();
		const existingTask = activeTasks.find((task) => task.metadata?.linear?.issue_id === issue.id);

		if (!existingTask) {
			console.error(`[LinearAgentMonitor] No active task found for ${issue.identifier}`);
			await this.addCommentToIssue(
				issue.id,
				'‚ùå **Agent task failed**: No active Vibe Coding task found for this Linear issue.\n\n' +
					'Please start a new implementation task first using the "Agent: implement" label.\n\n' +
					'---\nü§ñ *Claude Code*'
			);
			await this.removeLabelFromIssueById(issue.id, workingLabelId);
			await this.addLabelToIssue(issue.id, 'Agent/blocked');
			return false; // Blocked, no active task
		}

		// Check if there's an active connection for this task
		let conn = getActiveConnection(existingTask.id);
		if (!conn) {
			// Try to reconnect to the VM
			console.log(
				`[LinearAgentMonitor] No active connection for task ${existingTask.id}, attempting reconnect...`
			);
			await this.addCommentToIssue(
				issue.id,
				'üîÑ **Reconnecting to VM**\n\n' +
					'No active connection found (server may have restarted). Attempting to reconnect...\n\n' +
					'---\nü§ñ *Claude Code*'
			);

			const reconnected = await manualReconnect(existingTask.id);
			if (reconnected) {
				conn = getActiveConnection(existingTask.id);
			}

			if (!conn) {
				console.error(`[LinearAgentMonitor] Failed to reconnect to task ${existingTask.id}`);
				await this.addCommentToIssue(
					issue.id,
					'‚ùå **Agent task failed**: Could not reconnect to VM.\n\n' +
						'The VM may have been stopped. Please start a new implementation task.\n\n' +
						'---\nü§ñ *Claude Code*'
				);
				await this.removeLabelFromIssueById(issue.id, workingLabelId);
				await this.addLabelToIssue(issue.id, 'Agent/blocked');
				return false; // Blocked, reconnection failed
			}

			console.log(`[LinearAgentMonitor] Successfully reconnected to task ${existingTask.id}`);
			await this.addCommentToIssue(
				issue.id,
				'‚úÖ **Reconnected to VM**\n\n' +
					'Successfully reconnected. Sending fix instruction...\n\n' +
					'---\nü§ñ *Claude Code*'
			);
		}

		try {
			// Fetch comments from Linear to include in the instruction
			let issueWithComments: any = issue;
			try {
				const response = await fetch('https://api.linear.app/graphql', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						Authorization: await this.getApiKey(),
					},
					body: JSON.stringify({
						query: `
							query GetIssueWithComments($id: String!) {
								issue(id: $id) {
									id
									comments {
										nodes {
											body
											createdAt
											user {
												name
											}
										}
									}
								}
							}
						`,
						variables: { id: issue.id },
					}),
				});

				const data = await response.json();
				if (data.data?.issue?.comments) {
					issueWithComments = { ...issue, comments: data.data.issue.comments };
				}
			} catch (err) {
				console.error(
					`[LinearAgentMonitor] Failed to fetch comments for ${issue.identifier}:`,
					err
				);
			}

			// Build instruction text from description and last comment only
			let instructionText = '';

			if (issue.description) {
				instructionText += `${issue.description}\n\n`;
			}

			// Include only the last comment (most recent feedback)
			if (issueWithComments.comments?.nodes?.length > 0) {
				const lastComment =
					issueWithComments.comments.nodes[issueWithComments.comments.nodes.length - 1];
				const author = lastComment.user?.name || 'Unknown';
				instructionText += `Latest feedback from ${author}:\n\n${lastComment.body}\n\n`;
			}

			// Add suffix as requested
			instructionText += "Don't forget to update the merge request when done.";

			// Send Ctrl+C first to clear input buffer
			console.log(
				`[LinearAgentMonitor] Sending Ctrl+C to clear input buffer for task ${existingTask.id}`
			);
			conn.write('\x03'); // ASCII code 3 = Ctrl+C
			await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1 second

			// Send the instruction text
			console.log(
				`[LinearAgentMonitor] Sending fix implementation instruction to task ${existingTask.id}`
			);
			await sendInstruction(existingTask.id, instructionText);

			// Add comment to Linear
			await this.addCommentToIssue(
				issue.id,
				`üîß **Fix implementation instruction sent**\n\n` +
					`The agent has been instructed to fix the implementation based on your feedback.\n\n` +
					`[View Task Terminal ‚Üí](${env.APP_URL}/tasks/${existingTask.id})\n\n` +
					`---\nü§ñ *Claude Code*`
			);

			console.log(
				`[LinearAgentMonitor] Fix implementation instruction sent for ${issue.identifier}`
			);

			// Note: Keep Agent/working label - it will be updated by the vibe task workflow when done
			return true; // Successfully sent instruction
		} catch (error) {
			console.error(
				`[LinearAgentMonitor] Fix implementation task failed for ${issue.identifier}:`,
				error
			);
			await this.addCommentToIssue(
				issue.id,
				`‚ùå **Failed to send fix instruction**: ${error instanceof Error ? error.message : String(error)}\n\n` +
					`---\nü§ñ *Claude Code*`
			);
			await this.removeLabelFromIssueById(issue.id, workingLabelId);
			await this.addLabelToIssue(issue.id, 'Agent/blocked');
			throw error;
		}
	}

	private async executeCodeReviewTask(issue: LinearIssue, agentLabelId: string): Promise<boolean> {
		console.log(`[LinearAgentMonitor] Executing code review task for ${issue.identifier}`);

		// FIRST: Immediately swap label from Agent/Code Review to Agent/working
		const workingLabelId = await this.findLabel('Agent/working');
		if (!workingLabelId) {
			console.error(`[LinearAgentMonitor] Cannot find "Agent/working" label - aborting task`);
			await this.removeLabelFromIssue(issue.id, agentLabelId);
			await this.addCommentToIssue(
				issue.id,
				'‚ùå **Agent task failed**: Required label "Agent/working" not found in Linear.\n\n' +
					'Please create a "working" label under the "Agent" parent group.\n\n' +
					'---\nü§ñ *Claude Code*'
			);
			return false;
		}

		// Swap labels immediately to prevent duplicate pickup
		await this.removeLabelFromIssue(issue.id, agentLabelId);
		await this.addLabelToIssueById(issue.id, workingLabelId);
		console.log(
			`[LinearAgentMonitor] Swapped Agent/Code Review -> Agent/working for ${issue.identifier}`
		);

		// Find the existing active task for this Linear issue
		const activeTasks = await getActiveTasksWithLinearMetadata();
		const existingTask = activeTasks.find((task) => task.metadata?.linear?.issue_id === issue.id);

		if (!existingTask) {
			console.error(`[LinearAgentMonitor] No active task found for ${issue.identifier}`);
			await this.addCommentToIssue(
				issue.id,
				'‚ùå **Agent task failed**: No active Vibe Coding task found for this Linear issue.\n\n' +
					'Please start a new implementation task first using the "Agent: implement" label.\n\n' +
					'---\nü§ñ *Claude Code*'
			);
			await this.removeLabelFromIssueById(issue.id, workingLabelId);
			await this.addLabelToIssue(issue.id, 'Agent/blocked');
			return false;
		}

		// Check if MR URL is available
		if (!existingTask.mr_url) {
			console.error(`[LinearAgentMonitor] No GitLab MR URL found for task ${existingTask.id}`);
			await this.addCommentToIssue(
				issue.id,
				'‚ùå **Agent task failed**: No GitLab merge request found for this task.\n\n' +
					'Please ensure the agent created a merge request, or manually add the MR URL.\n\n' +
					'---\nü§ñ *Claude Code*'
			);
			await this.removeLabelFromIssueById(issue.id, workingLabelId);
			await this.addLabelToIssue(issue.id, 'Agent/blocked');
			return false;
		}

		// Check if there's an active connection for this task
		let conn = getActiveConnection(existingTask.id);
		if (!conn) {
			console.log(
				`[LinearAgentMonitor] No active connection for task ${existingTask.id}, attempting reconnect...`
			);
			await this.addCommentToIssue(
				issue.id,
				'üîÑ **Reconnecting to VM**\n\n' +
					'No active connection found. Attempting to reconnect...\n\n' +
					'---\nü§ñ *Claude Code*'
			);

			const reconnected = await manualReconnect(existingTask.id);
			if (reconnected) {
				conn = getActiveConnection(existingTask.id);
			}

			if (!conn) {
				console.error(`[LinearAgentMonitor] Failed to reconnect to task ${existingTask.id}`);
				await this.addCommentToIssue(
					issue.id,
					'‚ùå **Agent task failed**: Could not reconnect to VM.\n\n' +
						'The VM may have been stopped. Please start a new implementation task.\n\n' +
						'---\nü§ñ *Claude Code*'
				);
				await this.removeLabelFromIssueById(issue.id, workingLabelId);
				await this.addLabelToIssue(issue.id, 'Agent/blocked');
				return false;
			}

			console.log(`[LinearAgentMonitor] Successfully reconnected to task ${existingTask.id}`);
			await this.addCommentToIssue(
				issue.id,
				'‚úÖ **Reconnected to VM**\n\n' +
					'Successfully reconnected. Fetching code review feedback from GitLab...\n\n' +
					'---\nü§ñ *Claude Code*'
			);
		}

		try {
			// Fetch comprehensive code review context from GitLab MR
			console.log(`[LinearAgentMonitor] Fetching code review context from ${existingTask.mr_url}`);
			const instructionText = await this.codeReviewHandler.getCodeReviewInstruction(
				existingTask.id,
				existingTask.task_description,
				existingTask.mr_url
			);

			// Send Ctrl+C first to clear input buffer
			console.log(
				`[LinearAgentMonitor] Sending Ctrl+C to clear input buffer for task ${existingTask.id}`
			);
			conn.write('\x03');
			await new Promise((resolve) => setTimeout(resolve, 1000));

			// Send the comprehensive instruction
			console.log(
				`[LinearAgentMonitor] Sending code review instruction to task ${existingTask.id}`
			);
			await sendInstruction(existingTask.id, instructionText);

			// Add comment to Linear with summary
			await this.addCommentToIssue(
				issue.id,
				`üìã **Code Review Feedback Sent**\n\n` +
					`The agent has been provided with comprehensive feedback from the GitLab merge request:\n\n` +
					`**Merge Request**: ${existingTask.mr_url}\n\n` +
					`The agent will:\n` +
					`1. Review all comments on the MR (general and inline code comments)\n` +
					`2. Address each piece of feedback\n` +
					`3. Update the merge request with fixes\n` +
					`4. Comment on the MR with a summary of changes\n\n` +
					`[View Task Terminal ‚Üí](${env.APP_URL}/tasks/${existingTask.id})\n\n` +
					`---\nü§ñ *Claude Code*`
			);

			console.log(`[LinearAgentMonitor] Code review instruction sent for ${issue.identifier}`);

			return true;
		} catch (error) {
			console.error(`[LinearAgentMonitor] Code review task failed for ${issue.identifier}:`, error);
			await this.addCommentToIssue(
				issue.id,
				`‚ùå **Failed to fetch code review feedback**: ${error instanceof Error ? error.message : String(error)}\n\n` +
					`Please ensure:\n` +
					`- GitLab token is configured (GITLAB_TOKEN in .env)\n` +
					`- The merge request URL is valid\n` +
					`- You have access to the repository\n\n` +
					`---\nü§ñ *Claude Code*`
			);
			await this.removeLabelFromIssueById(issue.id, workingLabelId);
			await this.addLabelToIssue(issue.id, 'Agent/blocked');
			throw error;
		}
	}

	private async addCommentToIssue(issueId: string, comment: string) {
		const response = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: await this.getApiKey(),
			},
			body: JSON.stringify({
				query: `
					mutation CommentCreate($input: CommentCreateInput!) {
						commentCreate(input: $input) {
							success
							comment {
								id
							}
						}
					}
				`,
				variables: {
					input: {
						issueId,
						body: comment,
					},
				},
			}),
		});

		if (!response.ok) {
			throw new Error(`Failed to add comment: ${response.status} ${response.statusText}`);
		}

		const data = await response.json();
		if (data.errors) {
			throw new Error(`Failed to add comment: ${JSON.stringify(data.errors)}`);
		}
	}

	private async removeLabelFromIssue(issueId: string, labelId: string) {
		// Get current labels on the issue
		const issueResponse = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: await this.getApiKey(),
			},
			body: JSON.stringify({
				query: `
					query GetIssue($id: String!) {
						issue(id: $id) {
							labels {
								nodes {
									id
								}
							}
						}
					}
				`,
				variables: {
					id: issueId,
				},
			}),
		});

		const issueData = await issueResponse.json();
		const currentLabelIds =
			issueData.data?.issue?.labels?.nodes?.map((l: { id: string }) => l.id) || [];

		// Filter out the label to remove
		const newLabelIds = currentLabelIds.filter((id: string) => id !== labelId);

		// Update issue with new label list
		const response = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: await this.getApiKey(),
			},
			body: JSON.stringify({
				query: `
					mutation IssueUpdate($id: String!, $input: IssueUpdateInput!) {
						issueUpdate(id: $id, input: $input) {
							success
						}
					}
				`,
				variables: {
					id: issueId,
					input: {
						labelIds: newLabelIds,
					},
				},
			}),
		});

		if (!response.ok) {
			console.error(`Failed to remove label: ${response.status} ${response.statusText}`);
		}
	}

	private async addLabelToIssue(issueId: string, labelName: string) {
		// Find the label (do not create if missing)
		const labelId = await this.findLabel(labelName);

		if (!labelId) {
			console.error(
				`[LinearAgentMonitor] Cannot add label "${labelName}" - label not found in Linear`
			);
			return;
		}

		// Get current labels on the issue
		const issueResponse = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: await this.getApiKey(),
			},
			body: JSON.stringify({
				query: `
					query GetIssue($id: String!) {
						issue(id: $id) {
							labels {
								nodes {
									id
								}
							}
						}
					}
				`,
				variables: {
					id: issueId,
				},
			}),
		});

		const issueData = await issueResponse.json();
		const currentLabelIds =
			issueData.data?.issue?.labels?.nodes?.map((l: { id: string }) => l.id) || [];

		// Add new label if not already present
		if (!currentLabelIds.includes(labelId)) {
			currentLabelIds.push(labelId);
		}

		// Update issue with new label list
		const response = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: await this.getApiKey(),
			},
			body: JSON.stringify({
				query: `
					mutation IssueUpdate($id: String!, $input: IssueUpdateInput!) {
						issueUpdate(id: $id, input: $input) {
							success
						}
					}
				`,
				variables: {
					id: issueId,
					input: {
						labelIds: currentLabelIds,
					},
				},
			}),
		});

		if (!response.ok) {
			throw new Error(`Failed to add label: ${response.status} ${response.statusText}`);
		}
	}

	private async addLabelToIssueById(issueId: string, labelId: string) {
		// Get current labels on the issue
		const issueResponse = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: await this.getApiKey(),
			},
			body: JSON.stringify({
				query: `
					query GetIssue($id: String!) {
						issue(id: $id) {
							labels {
								nodes {
									id
								}
							}
						}
					}
				`,
				variables: { id: issueId },
			}),
		});

		const issueData = await issueResponse.json();
		const currentLabelIds =
			issueData.data?.issue?.labels?.nodes?.map((l: { id: string }) => l.id) || [];

		// Add new label if not already present
		if (!currentLabelIds.includes(labelId)) {
			currentLabelIds.push(labelId);
		}

		// Update issue with new label list
		const response = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: await this.getApiKey(),
			},
			body: JSON.stringify({
				query: `
					mutation IssueUpdate($id: String!, $input: IssueUpdateInput!) {
						issueUpdate(id: $id, input: $input) {
							success
						}
					}
				`,
				variables: {
					id: issueId,
					input: { labelIds: currentLabelIds },
				},
			}),
		});

		if (!response.ok) {
			throw new Error(`Failed to add label by ID: ${response.status} ${response.statusText}`);
		}
	}

	private async removeLabelFromIssueById(issueId: string, labelId: string) {
		// Get current labels on the issue
		const issueResponse = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: await this.getApiKey(),
			},
			body: JSON.stringify({
				query: `
					query GetIssue($id: String!) {
						issue(id: $id) {
							labels {
								nodes {
									id
								}
							}
						}
					}
				`,
				variables: { id: issueId },
			}),
		});

		const issueData = await issueResponse.json();
		const currentLabelIds =
			issueData.data?.issue?.labels?.nodes?.map((l: { id: string }) => l.id) || [];

		// Filter out the label to remove
		const newLabelIds = currentLabelIds.filter((id: string) => id !== labelId);

		// Update issue with new label list
		const response = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: await this.getApiKey(),
			},
			body: JSON.stringify({
				query: `
					mutation IssueUpdate($id: String!, $input: IssueUpdateInput!) {
						issueUpdate(id: $id, input: $input) {
							success
						}
					}
				`,
				variables: {
					id: issueId,
					input: { labelIds: newLabelIds },
				},
			}),
		});

		if (!response.ok) {
			console.error(`Failed to remove label by ID: ${response.status} ${response.statusText}`);
		}
	}

	/**
	 * Trigger a Vibe Coding task for the given issue
	 * This creates a VM task that will execute the implementation
	 */
	async triggerVibeTask(
		issue: LinearIssue,
		repoUrl: string,
		baseBranch: string = 'main',
		codingCli: 'claude-code' | 'gemini' | 'codex' = 'claude-code'
	): Promise<string> {
		console.log(`[LinearAgentMonitor] Triggering Vibe task for ${issue.identifier}`);

		// Use the issue creator's email for proper attribution
		// Fallback to linear-agent if creator email is not available
		const userId = issue.creator?.email?.split('@')[0] || 'linear-agent';
		const emailDomain = await configService.get('email.domain', 'your-domain.com', 'EMAIL_DOMAIN');
		const userEmail = issue.creator?.email || `linear-agent@${emailDomain}`;

		// Fetch comments from Linear
		let issueWithComments: any = issue;
		try {
			const response = await fetch('https://api.linear.app/graphql', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					Authorization: await this.getApiKey(),
				},
				body: JSON.stringify({
					query: `
						query GetIssueWithComments($id: String!) {
							issue(id: $id) {
								id
								comments {
									nodes {
										body
										createdAt
										user {
											name
										}
									}
								}
							}
						}
					`,
					variables: { id: issue.id },
				}),
			});

			const data = await response.json();
			if (data.data?.issue?.comments) {
				issueWithComments = { ...issue, comments: data.data.issue.comments };
			}
		} catch (err) {
			console.error(`[LinearAgentMonitor] Failed to fetch comments for ${issue.identifier}:`, err);
		}

		// Build comprehensive description with comments
		let description = `# ${issue.identifier}: ${issue.title}\n\nLinear: ${issue.url}\n\n`;

		if (issue.description) {
			description += `## Description\n\n${issue.description}\n\n`;
		}

		if (issueWithComments.comments?.nodes?.length > 0) {
			description += '## Comments\n\n';
			issueWithComments.comments.nodes.forEach((comment: any, idx: number) => {
				const author = comment.user?.name || 'Unknown';
				const date = new Date(comment.createdAt).toLocaleString();
				description += `### Comment ${idx + 1} by ${author} (${date})\n\n${comment.body}\n\n`;
			});
		}

		// Get default system prompt from config
		const defaultSystemPrompt = await configService.get(
			'agent.default_system_prompt',
			'',
			'AGENT_DEFAULT_SYSTEM_PROMPT'
		);

		const taskInput: TaskCreateInput = {
			repository: repoUrl,
			base_branch: baseBranch,
			task_description: description,
			coding_cli: codingCli,
			system_prompt: `This task was automatically triggered from Linear ticket ${issue.identifier}. Focus on implementing the requirements exactly as specified.

${defaultSystemPrompt}`,
		};

		const linearMetadata = {
			issue_id: issue.id,
			issue_identifier: issue.identifier,
			issue_url: issue.url,
			issue_title: issue.title,
		};

		// Create the task in database with Linear metadata
		const task = await createTask(userId, userEmail, taskInput, linearMetadata);

		// Start the VM and agent (async)
		startTask(task.id).catch((err) => {
			console.error(`[LinearAgentMonitor] Failed to start vibe task ${task.id}:`, err);
		});

		console.log(`[LinearAgentMonitor] Created Vibe task ${task.id} for ${issue.identifier}`);

		return task.id;
	}

	private async issueHasAgentWorkingLabel(issueId: string): Promise<boolean> {
		try {
			const response = await fetch('https://api.linear.app/graphql', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					Authorization: await this.getApiKey(),
				},
				body: JSON.stringify({
					query: `
						query GetIssueLabels($id: String!) {
							issue(id: $id) {
								labels {
									nodes {
										name
										parent {
											name
										}
									}
								}
							}
						}
					`,
					variables: { id: issueId },
				}),
			});

			const data = await response.json();
			const labels = data.data?.issue?.labels?.nodes || [];

			// Check if any label is "working" under "Agent" parent
			return labels.some(
				(label: { name: string; parent?: { name: string } | null }) =>
					label.name === 'working' && label.parent?.name === 'Agent'
			);
		} catch (error) {
			console.error(
				`[LinearAgentMonitor] Error checking Agent/working label for ${issueId}:`,
				error
			);
			// On error, assume it has the label to avoid blocking legitimate checks
			return true;
		}
	}

	private async findLabel(labelSpec: string): Promise<string | null> {
		// Parse label spec - supports "GroupName/LabelName" format for grouped labels
		const parts = labelSpec.split('/');
		const groupName = parts.length > 1 ? parts[0] : null;
		const labelName = parts.length > 1 ? parts[1] : parts[0];

		console.log(
			`[LinearAgentMonitor] Finding label: ${labelSpec} (group: ${groupName}, name: ${labelName})`
		);

		// Find existing label (with optional parent group filter)
		const findResponse = await fetch('https://api.linear.app/graphql', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				Authorization: await this.getApiKey(),
			},
			body: JSON.stringify({
				query: `
					query FindLabel($name: String!) {
						issueLabels(filter: { name: { eq: $name } }) {
							nodes {
								id
								name
								parent {
									id
									name
								}
							}
						}
					}
				`,
				variables: { name: labelName },
			}),
		});

		const findData = await findResponse.json();
		const labels = findData.data?.issueLabels?.nodes || [];

		console.log(
			`[LinearAgentMonitor] Found ${labels.length} labels matching "${labelName}":`,
			JSON.stringify(
				labels.map((l: { name: string; parent?: { name: string } }) => ({
					name: l.name,
					parent: l.parent?.name,
				}))
			)
		);

		// Find label matching the group if specified
		const existingLabel = groupName
			? labels.find((l: { parent?: { name: string } }) => l.parent?.name === groupName)
			: labels.find((l: { parent?: { name: string } }) => !l.parent);

		if (existingLabel) {
			console.log(`[LinearAgentMonitor] Found label: ${existingLabel.id}`);
			return existingLabel.id;
		}

		console.log(`[LinearAgentMonitor] Label not found: ${labelSpec}`);
		return null;
	}
}

// Export for use in server
export { LinearAgentMonitor };

// If running as standalone script
if (import.meta.url === `file://${process.argv[1]}`) {
	const monitor = new LinearAgentMonitor();

	// Handle graceful shutdown
	process.on('SIGINT', async () => {
		console.log('\n[LinearAgentMonitor] Received SIGINT, shutting down...');
		await monitor.stop();
		process.exit(0);
	});

	process.on('SIGTERM', async () => {
		console.log('\n[LinearAgentMonitor] Received SIGTERM, shutting down...');
		await monitor.stop();
		process.exit(0);
	});

	monitor.start().catch((error) => {
		console.error('[LinearAgentMonitor] Fatal error:', error);
		process.exit(1);
	});
}
